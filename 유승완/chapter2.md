# 시퀀스의 배열

## 파이썬은 모든 시퀀스를 일관성 있게 처리한다
- 모든 시퀀스 객체에는 반복, 슬라이싱, 정렬, 연결 등의 연산이 일관적으로 적용됨
- 이는 ABC언어의 특징을 물려받은 것!
- 파이썬에서 제공하는 다양한 시퀀스를 이해하면 새로 코드를 구현할 필요 없음


<details>
<summary>ABC언어란</summary>

- 파이썬의 조상님 **(전반적인 파이썬 컨셉의 모태)**
- 교육용/프로그래밍 초보자용 언어
- 인터프리터 방식, 문법이 간결
- Guido Van Rossum이 파이썬을 만들 때, ABC 언어의 좋은 점은 가져오고 단점은 보완

</details>

<br>
## 시퀀스?
- 순서가 있는 값들의 모음
- 인덱스로 접근할 수 있고, 값의 순서를 유지하는 자료형
- 인덱싱, 슬라이싱, 반복, 길이계산, 멤버 계산, 더하기 곱하기 가능
- __getitem__() / __len__() 이 두 메서드를 구현하면 커스텀 시퀀스 만들 수 있다.

<br>
## 내장 시퀀스
### 시퀀스 내 자료형에 따른 분류
- 컨테이너 시퀀스
  - 서로 다른 자료형 항목 담을 수 있음
  - 객체에 대한 참조를 담기 때문
  - list, tuple, collection.deque 등
- 균일 시퀀스
  - 단 하나의 자료형만 담을 수 있다.
  - 자신의 메모리 공간에 각 항목의 값을 직접 담음
  - str, bytes, array.array

### 가변성에 따른 분류
- 가변 시퀀스 - list, bytearray, array.array, collections.deque
- 불변 시퀀스 - tuple, str, bytes

<details>
<summary>파이썬 객체 헤더</summary>

- 모든 파이썬 객체에는 메타데이터를 담은 헤더가 있다!
- 예시) float 객체
  - ob_refcnt : 객체의 참조수
  - ob_type : 객체의 자료형에 대한 포인터
  - ob_fval : C언어의 double 형 실숫값
- 파이썬 64비트 버전에서 각 필드는 8바이트를 차지
- 실수 배열이 실수 튜플보다 메모리 적게 차지 -> 튜플은 튜플 객체 안에 포인터를 담기 때문

</details>

<br>

## 시퀀스를 만드는 간단한 방법
- List comprehension
- generator expression
  - 다른 생성자에 전달할 리스트를 통째로 만들지 않고 반복자 프로토콜을 통해 항목을 하나씩 생성
  - 메모리가 훨씬 적게 된다!
  - 만들지 않고 필요할 때 만들기! lazy execution
- 지능형 set, dic
- 잘 쓰면 코드를 아주 직관적이고 간결하게 만들 수 있다 -> 파이썬스러움

<details>
<summary>walrus operator</summary>

- 바다코끼리 연산자(:=)
- 표현식 안에서 값을 할당할 수 있게 해주는 연산자
- 표현식(expression)
  - 값을 만들어내는 것
  - 결과가 있는 것
  - 다른 곳(함수 인자, if 조건식 등)에 넣을 수 있음
  - 값을 생산(evaluate)
- 문(statemnet) : 행동을 하는 것
  - 행동(동작)을 수행하는 것
    - 할당, 조건, 함수호출, 반복 등
  - 값을 반환하지 않아도 된다
  - 코드의 구조를 이루는 뼈대
  - 실행(execute)
```python
while (line := input("입력:")) != "quit":
    print(f"입력한 값:{line}")

print(x=3) # statement는 print()안에 못들어간다!
print(x := 3) # 왈루스 연산자를 통해 표현식 안에서 변수 할당가능
```

</details>

<br>

## 튜플
- 불변리스트
- 필드명이 없는 레코드로 활용하기 아주 good
- 항목의 순서를 정해두고 레코드로 활용!
- 튜플의 장점
  - 명확성
    - 튜플의 길이가 절대 바뀌지 않음 확신
  - 성능
    - list보다 메모리 적게 소모
      - 길이 고정이라 메모리 효율적 할당
      - 튜플 참조는 튜플 구조체의 배열에 저장 vs 리스트는 다른 곳에 저장된 참조 배열에 대한 포인터를 가짐 -> 항목이 더 많아지면 참조 배열을 재할당 해야함 -> 한번 더 간접 참고하면 CPU 캐시 효율 감소
      - 튜플은 고정된 크기의 박스에 데이터를 직접 저장해
      - 각 요소가 연속된 공간에 저장돼 있어서 한 번에 쫙 읽을 수 있어
      - 메모리 구조도 깔끔하고 CPU 입장에서 캐시 히트율이 높음 → CPU가 "미리 읽어놓은 메모리(캐시)"에서 바로 가져올 확률이 높아짐
      - ```my_tuple = (1, "hi", 3.14)  # 튜플 내부 구조: [1]["hi"][3.14]가 연속된 메모리```
      - 리스트는 각 항목을 다른 곳에 저장해두고, 그걸 가리키는 포인터 배열만 저장하고 있음
      - 리스트가 커지면 참조 배열 크기 늘려야 함 (재할당) → 새로운 큰 배열 만들어서 기존 포인터 옮겨야 해
      - CPU 입장에서 보면, 메모리 접근을 한 번 더 우회해야 함 → 간접 참조 = 캐시 효율 떨어짐
      - ```my_list = [1, "hi", 3.14]  # 리스트 구조: [ptr1][ptr2][ptr3] # 그리고 각 ptr이 가리키는 곳에 값이 따로 있음```

- 튜플 내용 자체는 불변형
  - 하지만 이는 동일한 객체를 참조한다는 것이지 참조하는 객체가 바뀌면 내용이 바뀜(가변 항목을 담는 튜플은 주의!)

<br>

## 슬라이싱
- 슬라이싱 결과는 슬라이스 객체를 생성
- some_list[start:stop:step] -> some_list[slice(start, stop, step)]
- 특별 메서드(__getitem__())의 정의하여 슬라이싱 구현
- ```python
    class MySeq:
    def __getitem__(self, index):
        print(f"받은 인덱스: {index}")
    a = MySeq()
    a[1:5:2]  # 받은 인덱스: slice(1, 5, 2, None)
    ```

## list.sort() vs sorted()
- list.sort() : 사본을 만들지 않고 리스트 내부를 변경해 정렬
- sorted() : 새로운 리스트 생성해 반환
  - 불변 시퀀스, 제너레이터 등 반복 가능한 모든 객체를 인수로 받을 수 있음
- reverse, key 옵션을 활용하여 다양한 정렬 구현

## 리스트 말고 다른거 쓰는 경우!
- 배열
  - 고정 타입 숫자 저장
  - 메모리 효율 좋고, C 스타일 연산
- 메모리뷰
  - 큰 데이터 참조만 하고 복사 안 함
  - 빠르고, 메모리 절약
- 넘파이
  - 과학계산, 벡터/행렬 연산
  - 속도, 기능, 대규모 수치 연산
- deque
  - 빠른 양방향 추가/삭제, 큐 기능
  - 리스트보다 빠른 삽입/삭제
  - deque는 양쪽에서 O(1) 시간으로 push/pop 가능
- queue
  - 멀티스레딩 환경에서 안전하게 큐 사용하고 싶을 때
  - 기본 list나 deque는 스레드 안정성 X → queue 쓰면 OK
- heapq
  - 우선순위에 따라 작은 값부터 꺼내야 할 때
  - 알고리즘 문제 (예: 다익스트라, 힙정렬, 스케줄링 등)
  - 힙 : 이진트리 기반의 자료구조로, 항상 가장 작은 값이 루트에 있는 구조
