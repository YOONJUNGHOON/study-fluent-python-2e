## 코드 공부

#2.2

가변시퀀스: list, array.array 등
: 수정 가능한 시퀀스(순서가 있는 데이터, 인덱싱과 슬라이싱이 가능해야함)
불변시퀀스: tuple, str, bytes
: 수정 불가능한 시퀀스
dic은 시퀀스가 아님. dict은 키 기반 접근이기 때문.
set도 시퀀스가 아님. set은 순서가 없기 때문. 중복 제거 용도

#2.3

지능형 리스트 : for 문을 한 줄로 표현해서 리스트로 만드는 문법
ex)
a = [x for x in range(5)]
풀어쓰면
a = []
for x in range(5):
    a.append[x]

조건문도 가능
[x for x in range(5) if x%2 ==0]

바다코끼리 연산자란? 3.8에 도입
조건문이나 반복문에서 중복계산없이 변수 재활용하려고 사용, 변수에 값을 할당하여 즉시사용가능
변수:=값
ex)
while 루프 안에 할당 + 조건 검사 가능
line = input()
while a != "":
    print(line)

while (line := input()) !="" :
    print(line)
>>실제로 많이 쓰는지..??

지능형 리스트와 map()/filter() 비교 : 속도는 비슷, 직관 및 간결함의 차이
ex)
symbols = !@#$
지능형리스트
ascii = [ord(s) for s in symbols if ord(s)>127]
map/filter
ascii = list(filter(lambda cL c) 127, map(ord, symbols))

map(func, iterable) : iterable 요소를 func에 적용
ex)
a = [ 1,2,3]
b = map(lambda x: x^2, a)
b=[1,4,9]

filter(func, iterable) : iterable 에서 조건 만족하는 애들만 남김
ex)
c = filter(lambda x: x%2 ==0, a)
c = [2]

map에는 함수를 넣고 filter에는 조건문을 넣음.
lambda 함수 : 1회용 이름 없는 짧은 함수

제너레이터 표현식이란?
리스트 처럼 생겻지만 결과를 한번에 만들지 않고 하나씩 계산해서 내놓은 표현식
>>뭔솔?
튜플기호를 쓰지만 튜플과는 다름.
(x for x in iterable) 이런식으로 씀.

지능형 리스트와 []() 차이
지능형리스트는 한번에 계산, 제너레이터는 필요할때마다 하나씩 계산
즉 제너레이터 표현식은 리스트도 아니고 값 저장하지도 않음. 규칙을 저장한 객체
그래서 인수? 를 넣어주면 규칙 돌려서 값 반환.
값의 형태는 다 다름. 그럼 왜 시퀀스에서 다루냐?

시퀀스는 아니지만 iteration 값들을 생산하기 때문에, 지능형리스트와 사용방식 거의 비슷
제너레이터 표현식은 메모리에 보관할 필요 없는 데이터를 생성하는데 도움을 줌

#2.4

레코드 : 서로 관련된 데이터 묶음
튜플은 레코드를 담는다.
튜플의 각항목을 가져오는거 > 언패킹
관심이 없어 이름 부여않는 변수 > 더미변수 ( _사용)
튜플은 그 길이가 절대 바뀌지 않음.
리스트보다 메모리를 적게 소비함.
가변 항목이 있는 튜플은 버그의 원인이 될 수 있음.
값이 바뀌지 않는 객체만 해시 가능함.
hashable : hash value를 가질 수 있는 객체, hash : 고정된 크기 숫자로 바꾸는 함수 결과

리스트와 튜플 차이

튜플 리터럴을 평가하기 위해 파이썬 컴파일러는 한 번의 연산으로 튜플 상수에 대한 바이코드 생성
리스트 리터럴은 생성된 바이코드를 각 항목 별도의 상수로 만등러 데이터 스택에 쌓은 후 리스트 생성
: 이래서 효율성에 차이가 생김.
튜플의 값을 특정 값을 부르는건 해당 튜플의 특정 값을 참조하는 것
리스트는 특정 값을 복사한 후 그 복사값을 보여줌. 사본을 만들기때문에 효율성 떨어짐.
또한 리스트는 마지막 항목 뒤에 room 을 남김. > 데이터 비효율 야기

>>튜플과 리스트 메서드는 천천히 공부하자... 많이 쓰는 메서드 뭐가 있는지???

#2.5

언패킹 : 여러 값을 한번에 변수에 담기
ex)
a = (1, 2, 3)
b, c, d = a 하면 각각에 값이 담김
b, *c, d 이런식으로 하면 *에 한개이상의 요소가 담김
*c로 반환하는건 리스트로 묶음을 반환함.

시퀀스 리터럴도 *사용
시퀀스 리터럴 : 리스트나 튜플 안 다른 시퀀스를 펼쳐서 넣음
ex) 
e = (4, *a) = (4,1,2,3)
f = [4, *a] = [4,1,2,3]

#2.6

match/case : 3.10 추가, 가독성 유지보수 좋음
그러나 if 문과 효율 차이는 크게 있지 않음.
match 값:
    case 패턴1:
        실행1
    case 패턴2:
        실행2
    case _:
        기본실행

리스트 튜플의 구조매칭도 가능

if 대신 여러 패턴 검사 가능하고 타입 및 값 비교 한번에 가능

>>실사용 예시 잘 모르겠다.. 확인 필요

#2.7

슬라이싱 : 시퀀스[시작:끝:간격]
길이계산에 쉬움
[a:b:c]는 인덱스 연산을 수행하는 대괄호에서만 사용 가능
넘파이, array.array 등 다차원 배열에서도 슬라이싱 가능

파이썬 내장 시퀀스형은 1차원 구조이며 튜플은 지원하지 않음.

슬라이스로 할당할때에는 할당문 오른쪽에 반복가능한 객체 와야함.
ex)
l = [ 1,2,3]
l[0:1] = 100 > error
l[0:1] = [100] 로 해야함.

#2.8

덧셈에서는 피연산자 두개가 같은 자료형
곱셈은 시퀀스 그 자체를 반복복제함.

가변시퀀스(list, bytearray)에서는 얕은 복사만 수행함.
모든 요소가 같은 객체를 참조함.

#2.9

list.sort() : 사본을 만들지 않고 리스트 내부를 정렬해줌.
sorted() : 새로운 리스트를 생성해 반환해줌.

#2.10

list형을 지나치게 많이 사용하는 경향이 있지만 효율성 측면에서 고려해볼 것

어떤 항목이 들어있는지 검사하는 작업을 많이 수행할때는 set형으로 구현하는것을 고려.
set형은 항목이 들어있는 검사 과정에 최적화 되어있다.
시퀀스는 아님.

리스트 안에 숫자만 들어있다면 배열(array.array)이 리스트보다 훨씬 효과적임.

메모리뷰
>>뭔소린지 모르겠음. 아는사람?

넘파이 : 숫자뿐만 아니라 사용자 정의 레코드로 구성된 다차원 동형 배열 및 행렬을 만들고, 요소 단위에서 효율적으로 연산 가능하게 해줌.

큐 : FIFO, 시퀀스에서 append 나 pop(0) 사용시 선입선출됨.
덱 : 큐 양쪽 어디서든 빠르게 삽입 및 삭제할 수 있도록 설계된 스레드 안전한 양방향 큐

요약

시퀀스형을 제대로 파악해야 간결, 효율한 코드 가능함.
균일 시퀀스 : 작고 빠르고 사용하기 쉽지만 숫자, 문자, 바이트처럼 원자적 데이터만저장 가능, 모두 같은 자료형 참조하는 시퀀스
컨테이너 시퀀스 : 융통성있지만 가변 객체 저장시 예상치 못한 일 발생 가능, 여러 서로 다른 자료형 객체를 참조하는 시퀀스